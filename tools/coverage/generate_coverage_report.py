#!/usr/bin/env python3

import sys
import os
import argparse
import traceback
import subprocess
import logging
import json
import tempfile
from typing import List
from pathlib import Path

#===================================================================================================

def _run(cmd, **kwargs):
    if 'check' not in kwargs:
        kwargs.update({'check': True})
    logging.debug('Running => %s', ' '.join(cmd))
    return subprocess.run(cmd, **kwargs)

def _get_git_root() -> str:
    proc = _run('git rev-parse --show-toplevel'.split(), stdout=subprocess.PIPE)
    return proc.stdout.decode().strip()

#===================================================================================================

def generate_profdata_file(args: argparse.Namespace, outdir: str, name: str = 'default') -> Path:
    outfile = Path(outdir, f'{name}.profdata').resolve()
    cmd = f'llvm-profdata merge -sparse -o {outfile}'.split()
    profraws = [str(x) for x in args.profraw]
    cmd.extend(profraws)
    _run(cmd)
    return outfile

def output_simplified_report(args: argparse.Namespace, profdata: Path):
    cmd = f'llvm-cov report -instr-profile={profdata}'.split()
    tests = [str(x) for x in args.tests]
    cmd.extend(tests)
    _run(cmd)

def create_html_from_profdata(args: argparse.Namespace, profdata: Path):
    html_path = Path('html')
    os.makedirs(html_path, exist_ok=True)
    cmd = f'llvm-cov show -instr-profile={profdata} -format=html -output-dir={html_path}'.split()
    tests = [str(x) for x in args.tests]
    cmd.extend(tests)
    _run(cmd)
    if args.style:
        if not os.path.exists(args.style):
            raise ValueError(f'File {args.style} cannot be found')
        with open(args.style, 'r') as infile:
            with open(Path(html_path, 'style.css'), 'w') as outfile:
                outfile.write(infile.read())

#===================================================================================================

def _cmake_list(value: str) -> List[Path]:
    cm_list = value.split(';')
    for item in cm_list:
        if not os.path.exists(item):
            raise argparse.ArgumentTypeError(f'Expected a file "{item}" to exist')
    return [Path(x) for x in cm_list]
def _reformat_cmake_list(inlist: List[List[Path]]) -> List[Path]:
    retlist = []
    for item in inlist:
        retlist.extend(item)
    return retlist

def _existing_file(value: str) -> str:
    if not os.path.exists(value):
        raise argparse.ArgumentTypeError(f'Expected a file "{value}" to exist')
    return value

def _main() -> int:
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        '--tests',
        type=_cmake_list,
        required=True,
        nargs='+',
        help='Unit tests to use as the source of truth for code coverage.',
    )
    parser.add_argument(
        '--profraw',
        type=_cmake_list,
        required=True,
        nargs='+',
        help='Profraw files generated by the tests as a consequnce of building with coverage flags',
    )
    parser.add_argument(
        '--style',
        type=str,
        help='Use CSS style file instead of generated one.',
    )
    args = parser.parse_args()

    # Setup logging based on inputs

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(levelname)s: %(message)s',
    )

    # Unsure if space or semicolon separated list of tests will be passed in,
    # so we'll handle both cases and merge them here

    args.tests = _reformat_cmake_list(args.tests)
    args.profraw = _reformat_cmake_list(args.profraw)
    logging.debug('  Tests provided: %s', args.tests)
    logging.debug('Profraw provided: %s', args.profraw)

    # Export data into so it can be reprocessed

    temp_dir = tempfile.TemporaryDirectory()

    profdata = generate_profdata_file(args, temp_dir.name)

    create_html_from_profdata(args, profdata)


    # Output a condensed report table

    output_simplified_report(args, profdata)

if __name__ == '__main__':
    try:
        sys.exit(_main())
    except Exception as _e:
        traceback.print_exc()
        sys.exit(1)
